"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultApiHeaders = void 0;
const __1 = __importDefault(require("../"));
const errors_1 = require("../../errors");
exports.defaultApiHeaders = {
    'Content-Type': 'application/json',
    'Cache-Control': 'no-cache',
    // @ts-ignore
    ...(typeof window === 'undefined' ? {
        'Accept-Encoding': 'application/gzip'
    } : {})
};
const additionalHeaders = {
    marketplaceId: 'X-EBAY-C-MARKETPLACE-ID',
    endUserCtx: 'X-EBAY-C-ENDUSERCTX',
    acceptLanguage: 'Accept-Language',
    contentLanguage: 'Content-Language',
};
class Restful extends __1.default {
    constructor(config, req, auth, apiConfig = {}) {
        super(config, req, auth);
        this.apiConfig = {
            ...this.getApiConfig(),
            ...apiConfig
        };
    }
    static buildServerUrl(schema, subdomain, sandbox, tld) {
        return `${schema}${subdomain}.${sandbox ? 'sandbox.' : ''}${tld}`;
    }
    /**
     * Enable to supports the use of OAuth tokens for user authorization.
     */
    get useIaf() {
        return false;
    }
    get schema() {
        return 'https://';
    }
    get subdomain() {
        return 'api';
    }
    get apiVersionPath() {
        return '';
    }
    getServerUrl({ schema, subdomain, apiVersion, basePath, sandbox, tld }) {
        return Restful.buildServerUrl(schema, subdomain, sandbox, tld) + apiVersion + basePath;
    }
    getApiConfig() {
        return {
            subdomain: this.subdomain,
            useIaf: this.useIaf,
            apiVersion: this.apiVersionPath,
            basePath: this.basePath,
            schema: this.schema,
            sandbox: this.config.sandbox,
            tld: 'ebay.com',
            headers: {},
            returnResponse: false
        };
    }
    get baseUrl() {
        return this.getServerUrl(this.apiConfig);
    }
    /**
     * Create a new instances of it self with specified api config.
     * @param apiConfig
     */
    api(apiConfig) {
        // @ts-ignore
        return new this.constructor(this.config, this.req, this.auth, apiConfig);
    }
    /**
     * Use "apix" subdomain
     */
    get apix() {
        return this.api({ subdomain: 'apix' });
    }
    /**
     * Use "apiz" subdomain
     */
    get apiz() {
        return this.api({ subdomain: 'apiz' });
    }
    async get(url, config = {}, apiConfig) {
        return this.doRequest({ method: 'get', url, config }, apiConfig);
    }
    async delete(url, config = {}, apiConfig) {
        return this.doRequest({ method: 'delete', url, config }, apiConfig);
    }
    async post(url, data, config = {}, apiConfig) {
        return this.doRequest({ method: 'post', url, data, config }, apiConfig);
    }
    async put(url, data, config = {}, apiConfig) {
        return this.doRequest({ method: 'put', url, data, config }, apiConfig);
    }
    get additionalHeaders() {
        return Object.keys(additionalHeaders)
            // @ts-ignore
            .filter(key => typeof this.config[key] !== 'undefined')
            .reduce((headers, key) => {
            // @ts-ignore
            headers[additionalHeaders[key]] = this.config[key];
            return headers;
        }, {});
    }
    async enrichRequestConfig(config = {}, apiConfig = this.apiConfig) {
        const authHeader = await this.auth.getHeaderAuthorization(apiConfig.useIaf);
        const headers = {
            ...exports.defaultApiHeaders,
            ...this.additionalHeaders,
            ...authHeader,
            ...apiConfig.headers
        };
        return {
            ...config,
            headers: {
                ...(config.headers || {}),
                ...headers
            }
        };
    }
    async doRequest(payload, apiConfig) {
        try {
            return await this.request(payload, apiConfig);
        }
        catch (error) {
            if (this.shouldRefreshToken(error)) {
                // Try again and refresh token
                return await this.request(payload, apiConfig, true /* refresh token */);
            }
            throw error;
        }
    }
    shouldRefreshToken(error) {
        if (!this.config.autoRefreshToken) {
            return false;
        }
        if (error.name === errors_1.EBayInvalidAccessToken.name) {
            return true;
        }
        return error?.meta?.res?.status === 401 && this.apiConfig.basePath === '/post-order/v2';
    }
    async request(apiRequest, apiConfig = this.apiConfig, refreshToken = false) {
        const { url, method, data, config } = apiRequest;
        const apiCfg = { ...this.apiConfig, ...apiConfig };
        const endpoint = this.getServerUrl(apiCfg) + url;
        try {
            if (refreshToken) {
                await this.auth.OAuth2.refreshToken();
            }
            const enrichedConfig = await this.enrichRequestConfig(config, apiCfg);
            const args = ['get', 'delete'].includes(method) ? [enrichedConfig] : [data, enrichedConfig];
            // @ts-ignore
            const response = await this.req[method](endpoint, ...args);
            if (this.apiConfig.returnResponse) {
                return response;
            }
            else {
                return response.data;
            }
        }
        catch (ex) {
            (0, errors_1.handleEBayError)(ex);
        }
    }
}
exports.default = Restful;
//# sourceMappingURL=index.js.map