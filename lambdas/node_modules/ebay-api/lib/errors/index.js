"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkEBayResponse = exports.handleEBayError = exports.mapEBayError = exports.EBayInvalidScope = exports.EBayTokenRequired = exports.EBayIAFTokenInvalid = exports.EBayIAFTokenExpired = exports.EBayInvalidAccessToken = exports.EBayNotFound = exports.EBayInvalidGrant = exports.EBayAccessDenied = exports.EbayApiError = exports.getErrorDescription = exports.getErrorMessage = exports.ApiEnvError = exports.EbayNoCallError = exports.EBayError = exports.rawError = void 0;
// tslint:disable:max-classes-per-file
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('ebay:error');
exports.rawError = Symbol('raw-error');
/**
 * Error object for ease of capturing if some service depends on .toJSON() method to log something
 *
 * @ignore
 */
class EBayError extends Error {
    constructor(message, description = '', meta = {}) {
        super(message);
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = this.constructor.name;
        this.description = description;
        this.meta = meta;
    }
    /**
     * returns a JSON representation of the Error
     *
     * @return     {Object}  json representation of the Error
     */
    toJSON() {
        return {
            message: this.message,
            description: this.description,
            stack: this.stack,
            type: this.constructor.name,
            meta: this.meta || null
        };
    }
}
exports.EBayError = EBayError;
/**
 * thrown when Request.prototype.run() is called without having defined an eBay API call
 */
class EbayNoCallError extends EBayError {
    constructor(msg = 'No eBay API call defined, please invoke one.') {
        super(msg);
    }
}
exports.EbayNoCallError = EbayNoCallError;
/**
 * thrown when attempting to load environment variables that don't exist
 */
class ApiEnvError extends EBayError {
    constructor(key) {
        super(`Could not find ${key} in process.env.`);
    }
}
exports.ApiEnvError = ApiEnvError;
const getErrorMessage = (err) => err.response?.data?.message
    || err.response?.data?.error?.[0]?.message
    || err.response?.data?.errors?.[0]?.message
    || err.errorMessage?.error?.message
    || err.Errors?.ShortMessage
    || err.message
    || 'eBay API request error';
exports.getErrorMessage = getErrorMessage;
const getErrorDescription = (err) => err.response?.data?.error_description
    || err.response?.data?.error?.[0]?.longMessage
    || err.response?.data?.errors?.[0]?.longMessage
    || err.longMessage
    || err.Errors?.LongMessage
    || err.response?.statusText
    || '';
exports.getErrorDescription = getErrorDescription;
/**
 * Thrown when an Error occurs on eBay's side.
 */
class EbayApiError extends EBayError {
    constructor(err) {
        const { message, description, meta } = (0, exports.mapEBayError)(err);
        super(message, description, meta);
    }
}
exports.EbayApiError = EbayApiError;
class EBayAccessDenied extends EbayApiError {
}
exports.EBayAccessDenied = EBayAccessDenied;
class EBayInvalidGrant extends EbayApiError {
}
exports.EBayInvalidGrant = EBayInvalidGrant;
class EBayNotFound extends EbayApiError {
}
exports.EBayNotFound = EBayNotFound;
EBayNotFound.code = 11001;
class EBayInvalidAccessToken extends EbayApiError {
}
exports.EBayInvalidAccessToken = EBayInvalidAccessToken;
class EBayIAFTokenExpired extends EbayApiError {
}
exports.EBayIAFTokenExpired = EBayIAFTokenExpired;
EBayIAFTokenExpired.code = 21917053;
class EBayIAFTokenInvalid extends EbayApiError {
}
exports.EBayIAFTokenInvalid = EBayIAFTokenInvalid;
EBayIAFTokenInvalid.code = 21916984;
class EBayTokenRequired extends EbayApiError {
}
exports.EBayTokenRequired = EBayTokenRequired;
EBayTokenRequired.code = 930;
class EBayInvalidScope extends EbayApiError {
}
exports.EBayInvalidScope = EBayInvalidScope;
const mapEBayError = (err) => {
    if (!err) {
        return {};
    }
    let eBayError = {};
    if (err.response?.data) {
        const data = err.response.data;
        if (Array.isArray(data.error)) {
            eBayError = data.error[0] ?? data;
        }
        else if (Array.isArray(data.errors)) {
            eBayError = data.errors[0] ?? data;
        }
        else if (typeof data.error === 'string') {
            eBayError = {
                message: data.error,
                description: data.error_description || ''
            };
        }
        else {
            eBayError = data;
        }
    }
    else if (err.Errors) {
        eBayError = err;
    }
    const error = {
        message: eBayError.message || (0, exports.getErrorMessage)(err),
        description: eBayError.description || (0, exports.getErrorDescription)(err),
        meta: {
            ...eBayError,
            [exports.rawError]: err
        }
    };
    if (err.response) {
        error.meta.res = {
            status: err.response.status,
            statusText: err.response.statusText,
            headers: err.response.headers,
            data: err.response.data ?? {}
        };
    }
    if (err.request && err.config) {
        error.meta.req = {
            url: err.config.url,
            method: err.config.method,
            headers: err.config.headers,
            params: err.config.params
        };
    }
    return error;
};
exports.mapEBayError = mapEBayError;
const handleEBayError = (err) => {
    log('handleEBayError', err);
    if (err instanceof EBayError) {
        throw err;
    }
    const { message, meta, description } = (0, exports.mapEBayError)(err);
    if (meta.domain === 'ACCESS') {
        throw new EBayAccessDenied(err);
    }
    else if (meta.message === 'invalid_grant') {
        throw new EBayInvalidGrant(err);
    }
    else if (meta.errorId === EBayNotFound.code) {
        throw new EBayNotFound(err);
    }
    else if (meta.message === 'invalid_scope') {
        throw new EBayInvalidScope(err);
    }
    else if (meta.message === 'Invalid access token') {
        throw new EBayInvalidAccessToken(err);
    }
    throw new EBayError(message, description, meta);
};
exports.handleEBayError = handleEBayError;
const checkEBayResponse = (data) => {
    if (data.Ack === 'Failure') {
        if (data.Errors?.ErrorCode) {
            switch (data.Errors.ErrorCode) {
                case EBayIAFTokenExpired.code:
                    throw new EBayIAFTokenExpired(data);
                case EBayIAFTokenInvalid.code:
                    throw new EBayIAFTokenInvalid(data);
                case EBayTokenRequired.code:
                    throw new EBayTokenRequired(data);
            }
        }
        throw new EbayApiError(data);
    }
    else if (data.errorMessage) {
        throw new EbayApiError(data);
    }
};
exports.checkEBayResponse = checkEBayResponse;
//# sourceMappingURL=index.js.map